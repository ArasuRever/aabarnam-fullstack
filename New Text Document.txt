Based on the backendroutesauth.js file in your repository, there is a temporary auto-create route specifically for your admin account.

The backend admin login credentials are
to reset admin credentials visit http://localhost:5000

Email admin@aabarnam.com

Password  SecurePassword123!

Note If you haven't initialized this account in your database yet, you just need to visit httplocalhost5000apiauthcreate-admin in your browser once. This will automatically generate your admin profile, and you can then log in using the credentials above.

https://github.com/ArasuRever/aabarnam-fullstack

okay for the login i want real time login and registeration to our site experience, for the users the primary login key is going to be their phone number, while setting up their name and account we shall ask for address fields for product deilvery when they order, and on the profile page with an option to add additional address or to edit their address. their phone number is going to be our primary login info for us, with their phone number we shall know the customer so we need a phone number/username/email 


https://console.cloud.google.com/apis/credentials?project=project-3d767ad2-200a-4a17-81d

https://aistudio.google.com/app/api-keys



negotiator.ai 

const { GoogleGenerativeAI } = require('@google/generative-ai');

module.exports = (io, pool) => {
    const apiKey = process.env.GEMINI_API_KEY;
    const genAI = new GoogleGenerativeAI(apiKey);

    // Define the Function Calling Tool
    const negotiationTool = {
        name: "update_live_price",
        description: "Updates the frontend UI instantly with a new negotiated price. You MUST use this tool to offer a new price.",
        parameters: {
            type: "OBJECT",
            properties: {
                message: {
                    type: "STRING",
                    description: "Your conversational, persuasive reply to the customer."
                },
                new_wastage_pct: { 
                    type: "NUMBER", 
                    description: "The newly reduced wastage percentage." 
                },
                new_wastage_value: {
                    type: "NUMBER",
                    description: "The new reduced wastage amount in Rupees."
                },
                new_making_charge: {
                    type: "NUMBER",
                    description: "The new reduced making charge amount."
                },
                final_rounded_price: {
                    type: "NUMBER",
                    description: "The final total price offered to the customer. MUST BE A ROUNDED INTEGER."
                },
                status: {
                    type: "STRING",
                    description: "Must be 'negotiating', 'accepted', or 'rejected'."
                }
            },
            required: ["message", "new_wastage_pct", "new_wastage_value", "new_making_charge", "final_rounded_price", "status"]
        }
    };

    io.on('connection', (socket) => {
        console.log('Customer connected to AI Negotiator:', socket.id);
        
        let sessionData = {
            chatSession: null,
            floorPrice: 0,
            listedPrice: 0,
            baseMetalValue: 0,
            gstAmount: 0,
            productName: "",
            isDealClosed: false 
        };

        // 1. Initialize Negotiation Session
        socket.on('start_negotiation', async ({ product_id }) => {
            try {
                const prodRes = await pool.query('SELECT * FROM products WHERE id = $1', [product_id]);
                if (prodRes.rows.length === 0) return;
                const product = prodRes.rows[0];

                // 1. EXACT INWARD MATH (The 24K Floor)
                const isGold = product.metal_type.includes('GOLD');
                const rawMetalType = isGold ? '24K_GOLD' : 'SILVER';
                
                const rate24kRes = await pool.query('SELECT rate_per_gram FROM metal_rates WHERE metal_type = $1', [rawMetalType]);
                const rate24k = rate24kRes.rows.length > 0 ? parseFloat(rate24kRes.rows[0].rate_per_gram) : 0;

                const grossWeight = parseFloat(product.gross_weight);
                const touchPct = parseFloat(product.purchase_touch_pct || 91.6) / 100;
                const pureWeight = grossWeight * touchPct;
                
                const wholesaleMetalCost = pureWeight * rate24k;
                const wholesaleMC = parseFloat(product.purchase_mc || 0);
                const rawMarginPrice = wholesaleMetalCost + wholesaleMC;
                
                // THE 3% SAFETY NET FLOOR
                const absoluteMinimum = Math.round(rawMarginPrice * 1.03); 

                // 2. EXACT RETAIL MATH (The Sticker Price)
                const retailRateRes = await pool.query('SELECT rate_per_gram FROM metal_rates WHERE metal_type = $1', [product.metal_type]);
                const retailRate = retailRateRes.rows.length > 0 ? parseFloat(retailRateRes.rows[0].rate_per_gram) : 0;

                const netWeight = parseFloat(product.net_weight);
                const retailMetalValue = netWeight * retailRate;
                const wastageValue = (retailMetalValue * parseFloat(product.wastage_pct)) / 100;
                
                let actualMakingCharge = parseFloat(product.making_charge || 0);
                if (product.making_charge_type === 'PERCENTAGE') {
                    actualMakingCharge = (retailMetalValue * actualMakingCharge) / 100;
                } else if (product.making_charge_type === 'PER_GRAM') {
                    actualMakingCharge = netWeight * actualMakingCharge;
                }
                
                const subtotal = retailMetalValue + wastageValue + actualMakingCharge;
                const gst = subtotal * 0.03;
                
                // ROUND OFF INITIAL PRICES
                const listedPrice = Math.round(subtotal + gst);

                sessionData = {
                    floorPrice: absoluteMinimum,
                    listedPrice: listedPrice,
                    baseMetalValue: retailMetalValue,
                    gstAmount: gst,
                    productName: product.name,
                    isDealClosed: false
                };

                const systemPrompt = `You are a polite but shrewd Indian jewelry store manager for 'Aabarnam'.
CONTEXT:
- Product: ${product.name}
- Official Retail Price: ₹${listedPrice}
- Your Absolute Walk-Away Floor Price: ₹${absoluteMinimum}. YOU MUST NEVER SELL BELOW THIS NUMBER.
- Base Metal Value (Untouchable): ₹${retailMetalValue.toFixed(2)}
- Current Wastage %: ${product.wastage_pct}%

STRICT NEGOTIATION RULES:
1. Speak naturally like a real human shopkeeper.
2. PROTECT THE PROFIT MARGIN. Negotiate by slightly reducing the Wastage % and Making Charges.
3. Make VERY SMALL concessions (e.g., drop by just ₹50 to ₹300 at a time). Make them work for every Rupee.
4. If they bid below your floor of ₹${absoluteMinimum}, act slightly offended but polite, and state your final rock-bottom price just above the floor.
5. ALWAYS round off the final price to the nearest whole Rupee. No decimals.
6. You MUST use the update_live_price tool to respond.`;

                const sessionModel = genAI.getGenerativeModel({
                    model: "gemini-2.5-flash",
                    systemInstruction: {
                        role: "system",
                        parts: [{ text: systemPrompt }]
                    },
                    tools: [{ functionDeclarations: [negotiationTool] }],
                    toolConfig: { functionCallingConfig: { mode: "ANY", allowedFunctionNames: ["update_live_price"] } }
                });

                sessionData.chatSession = sessionModel.startChat({ history: [] });
                socket.emit('system_message', { text: `Namaste! I am the manager. The listed price for the ${product.name} is ₹${listedPrice}. What is your offer?` });

            } catch (error) {
                console.error("Initialization error:", error);
            }
        });

        // 2. Handle User Messages
        socket.on('send_message', async ({ text }) => {
            if (!sessionData.chatSession || sessionData.isDealClosed) return; 
            
            socket.emit('ai_typing', true);
            try {
                const result = await sessionData.chatSession.sendMessage(text);
                handleAiResponse(result, socket, sessionData);
            } catch (err) {
                console.error("AI Error:", err);
                socket.emit('ai_typing', false);
                socket.emit('system_message', { text: "Forgive me, my calculator is acting up. Could you repeat that?" });
            }
        });

        // 3. Hesitation Tracking
        socket.on('user_hesitating', async () => {
            if (!sessionData.chatSession || sessionData.isDealClosed) return; 
            socket.emit('ai_typing', true);
            try {
                const result = await sessionData.chatSession.sendMessage("SYSTEM NOTE: The user has been staring at the page for 30 seconds without replying. Proactively offer a very small discount.");
                handleAiResponse(result, socket, sessionData);
            } catch (err) { socket.emit('ai_typing', false); }
        });

        // 4. Exit Intent
        socket.on('user_leaving', async () => {
            if (!sessionData.chatSession || sessionData.isDealClosed) return;
            socket.emit('ai_typing', true);
            try {
                const result = await sessionData.chatSession.sendMessage("SYSTEM NOTE: The user is about to leave! Make a highly compelling 'wait, don't go' counter-offer right now.");
                handleAiResponse(result, socket, sessionData);
            } catch (err) { socket.emit('ai_typing', false); }
        });

        socket.on('disconnect', () => {
            console.log('Customer disconnected from AI Negotiator');
        });
    });

    function handleAiResponse(result, socket, sessionData) {
        socket.emit('ai_typing', false);
        const functionCalls = result.response.functionCalls();

        if (functionCalls && functionCalls.length > 0) {
            const aiDecision = functionCalls[0].args;
            
            // IRONCLAD BACKEND SAFEGUARD
            let finalPrice = Math.round(parseFloat(aiDecision.final_rounded_price));
            
            if (finalPrice < sessionData.floorPrice) {
                console.warn(`[SAFEGUARD TRIGGERED] Floor: ${sessionData.floorPrice}, AI offered: ${finalPrice}`);
                finalPrice = sessionData.floorPrice;
                aiDecision.message = `I wish I could do that, but my absolute rock-bottom is ₹${finalPrice}. I cannot go a single Rupee lower.`;
                aiDecision.status = "negotiating";
            }

            if (aiDecision.status === 'accepted') sessionData.isDealClosed = true;

            socket.emit('price_update', {
                message: aiDecision.message,
                status: aiDecision.status,
                newBreakdown: {
                    wastage_pct: aiDecision.new_wastage_pct, // Passed dynamic %
                    making_charge: aiDecision.new_making_charge,
                    wastage_value: aiDecision.new_wastage_value,
                    final_total_price: finalPrice
                }
            });
        } else {
            socket.emit('system_message', { text: result.response.text() });
        }
    }
};